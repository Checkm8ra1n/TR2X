#!/usr/bin/python3
import re
from collections.abc import Callable, Iterable
from dataclasses import dataclass
from decimal import Decimal
from enum import StrEnum, auto
from itertools import groupby
from pathlib import Path
from typing import Any

DOCUMENT_MARGIN = Decimal(2)
GRID_MAX_SQUARES = 50
GRID_SQUARE_SIZE = Decimal(12)
GRID_SQUARE_MARGIN = Decimal(3)
LEGEND_SQUARE_SIZE = GRID_SQUARE_SIZE
LEGEND_SQUARE_MARGIN = GRID_SQUARE_MARGIN
LEGEND_ROW_PADDING = Decimal(3)
LEGEND_MARGIN = Decimal(15)
TEXT_SIZE = Decimal(15)
TEXT_MARGIN = Decimal(5)
SECTION_MARGIN = GRID_SQUARE_SIZE + LEGEND_MARGIN
DOCS_DIR = Path(__file__).parent.parent / "docs"
PROGRESS_TXT_FILE = DOCS_DIR / "progress.txt"
PROGRESS_SVG_FILE = DOCS_DIR / "progress.svg"
ZERO = Decimal(0)


class SumMode(StrEnum):
    BYTES = auto()
    COUNT = auto()


class FunctionStatus(StrEnum):
    TODO = auto()
    NAMED = auto()
    DECOMPILED = auto()


def format_decimal(source: Decimal) -> str:
    return str(source.quantize(Decimal('1.11'))).replace('.00', '')

@dataclass
class Box:
    x1: Decimal
    y1: Decimal
    x2: Decimal
    y2: Decimal

    @property
    def dx(self) -> Decimal:
        return self.x2 - self.x1

    @property
    def dy(self) -> Decimal:
        return self.y2 - self.y1


@dataclass
class SquarifyResult(Box):
    item: Any


class Squarify:
    def __init__(
        self,
        items: Iterable[Any],
        key: Callable[[Any], Decimal],
        box: Box,
        normalize: bool = True,
    ) -> None:
        self.key: Callable[[Any], Decimal] = key

        if normalize:
            total_size = sum(map(key, items))
            total_area = box.dx * box.dy

            def normalized_key(item: Any) -> Decimal:
                return key(item) * total_area / total_size

            self.key = normalized_key

        self.items = list(sorted(items, key=self.key, reverse=True))
        self.box = box

    def layoutrow(self, items: Iterable[Any]) -> Iterable[SquarifyResult]:
        covered_area = sum(self.key(item) for item in items)
        dx = covered_area / self.box.dy
        y = self.box.y1
        for item in items:
            yield SquarifyResult(
                item=item,
                x1=self.box.x1,
                y1=y,
                x2=self.box.x1 + dx,
                y2=y + self.key(item) / dx,
            )
            y += self.key(item) / dx

    def layoutcol(self, items: Iterable[Any]) -> Iterable[SquarifyResult]:
        covered_area = sum(self.key(item) for item in items)
        dy = covered_area / self.box.dx
        x = self.box.x1
        for item in items:
            yield SquarifyResult(
                item=item,
                x1=x,
                y1=self.box.y1,
                x2=x + self.key(item) / dy,
                y2=self.box.y1 + dy,
            )
            x += self.key(item) / dy

    def layout(self, items: Iterable[Any]) -> Iterable[SquarifyResult]:
        yield from (
            self.layoutrow(items)
            if self.box.dx >= self.box.dy
            else self.layoutcol(items)
        )

    def leftoverrow(self, items: Iterable[Any]) -> Box:
        covered_area = sum(self.key(item) for item in items)
        dx = covered_area / self.box.dy
        return Box(
            x1=self.box.x1 + dx,
            y1=self.box.y1,
            x2=self.box.x1 + self.box.dx,
            y2=self.box.y1 + self.box.dy,
        )

    def leftovercol(self, items: Iterable[Any]) -> Box:
        covered_area = sum(self.key(item) for item in items)
        dy = covered_area / self.box.dx
        return Box(
            x1=self.box.x1,
            y1=self.box.y1 + dy,
            x2=self.box.x1 + self.box.dx,
            y2=self.box.y1 + self.box.dy,
        )

    def leftover(self, items: Iterable[Any]) -> Box:
        return (
            self.leftoverrow(items)
            if self.box.dx >= self.box.dy
            else self.leftovercol(items)
        )

    def worst_ratio(self, items: Iterable[Any]) -> Decimal:
        return max(
            max(result.dx / result.dy, result.dy / result.dx)
            for result in self.layout(items)
        )

    def run(self, items: list[Any] | None = None) -> Iterable[SquarifyResult]:
        if not items:
            items = self.items

        if len(items) == 0:
            return

        if len(items) == 1:
            yield from self.layout(items)
            return

        i = 1
        while i < len(items) and self.worst_ratio(
            items[:i]
        ) >= self.worst_ratio(items[: i + 1]):
            i += 1
        current = items[:i]
        remaining = items[i:]

        leftover_box = self.leftover(current)
        yield from self.layout(current)
        yield from Squarify(
            remaining, key=self.key, box=leftover_box, normalize=False
        ).run()


def squarify(
    items: list[Any], key: Callable[[Any], Decimal], box: Box
) -> Iterable[SquarifyResult]:
    yield from Squarify(items, key, box).run()


@dataclass
class Function:
    signature: str
    offset: int
    size: int
    flags: str

    @property
    def is_decompiled(self) -> bool:
        return "+" in self.flags or "x" in self.flags

    @property
    def is_called(self) -> bool:
        return "*" in self.flags

    @property
    def is_named(self) -> bool:
        return not re.search(r"(\s|^)sub_", self.signature)

    @property
    def status(self) -> FunctionStatus:
        if self.is_decompiled:
            return FunctionStatus.DECOMPILED
        elif self.is_named:
            return FunctionStatus.NAMED
        return FunctionStatus.TODO


def collect_functions() -> Iterable[Function]:
    in_functions = False
    for line in PROGRESS_TXT_FILE.open():
        line = line.strip()
        if line == "# FUNCTIONS":
            in_functions = True
        elif re.match("^# [A-Z]*$", line):
            in_functions = False
        if not in_functions:
            continue

        if line.startswith("#") or not line:
            continue
        offset, size, flags, func_signature = re.split(
            r"\s+", line, maxsplit=3
        )
        if not offset.replace("-", ""):
            continue
        yield Function(
            signature=func_signature,
            offset=int(offset, 16),
            size=int(size, 16),
            flags=flags,
        )


class Shape:
    @property
    def box(self) -> Box:
        raise NotImplementedError("not implemented")

    def render(self) -> str:
        raise NotImplementedError("not implemented")


def get_common_bbox(shapes: list[Shape]) -> Box:
    return Box(
        x1=min(shape.box.x1 for shape in shapes),
        y1=min(shape.box.y1 for shape in shapes),
        x2=max(shape.box.x2 for shape in shapes),
        y2=max(shape.box.y2 for shape in shapes),
    )


@dataclass
class Rectangle(Shape):
    x: Decimal
    y: Decimal
    class_name: str
    dx: Decimal
    dy: Decimal
    title: str | None = None

    @property
    def box(self) -> Box:
        return Box(
            x1=self.x,
            y1=self.y,
            x2=self.x + self.dx,
            y2=self.y + self.dy,
        )

    def render(self) -> str:
        return (
            f"<rect "
            f'width="{format_decimal(self.dx)}" '
            f'height="{format_decimal(self.dy)}" '
            f'x="{format_decimal(self.x)}" '
            f'y="{format_decimal(self.y)}" '
            f'class="{self.class_name}"'
            + (f"><title>{self.title}</title></rect>" if self.title else "/>")
        )


class Square(Rectangle):
    def __init__(
        self,
        x: Decimal,
        y: Decimal,
        class_name: str,
        size: Decimal = GRID_SQUARE_SIZE,
        title: str | None = None,
    ) -> None:
        super().__init__(
            x=x, y=y, class_name=class_name, dx=size, dy=size, title=title
        )


@dataclass
class Text(Shape):
    x: Decimal
    y: Decimal
    text: str

    @property
    def box(self) -> Box:
        return Box(x1=self.x, y1=self.y, x2=self.x, y2=self.y + TEXT_SIZE)

    def render(self) -> str:
        return (
            f"<text "
            f'x="{format_decimal(self.x)}" '
            f'y="{format_decimal(self.y + TEXT_SIZE/2)}">'
            f"{self.text}"
            f"</text>"
        )


@dataclass
class LegendText(Shape):
    x: Decimal
    y: Decimal
    class_name: str
    text: str

    @property
    def _square(self) -> Square:
        return Square(
            x=self.x,
            y=self.y + (TEXT_SIZE - LEGEND_SQUARE_SIZE) / 2,
            class_name=self.class_name,
            size=LEGEND_SQUARE_SIZE,
        )

    @property
    def _text(self) -> Text:
        return Text(
            x=LEGEND_SQUARE_SIZE + TEXT_MARGIN,
            y=self.y,
            text=self.text,
        )

    @property
    def box(self) -> Box:
        return get_common_bbox([self._square, self._text])

    def render(self) -> str:
        return self._square.render() + self._text.render()


def render_grid(all_functions: list[Function], by: Decimal) -> Iterable[Shape]:
    for i, function in enumerate(all_functions):
        x = (i % GRID_MAX_SQUARES) * (GRID_SQUARE_SIZE + GRID_SQUARE_MARGIN)
        y = (i // GRID_MAX_SQUARES) * (GRID_SQUARE_SIZE + GRID_SQUARE_MARGIN)
        yield Square(
            x=x,
            y=by + y,
            class_name=function.status.value,
            title=function.signature,
        )


def render_tree_grid(
    all_functions: list[Function], box: Box
) -> Iterable[Shape]:
    for result in squarify(
        all_functions, key=lambda function: Decimal(function.size), box=box
    ):
        result.x2 = max(ZERO, result.x2 - GRID_SQUARE_MARGIN)
        result.y2 = max(ZERO, result.y2 - GRID_SQUARE_MARGIN)

        yield Rectangle(
            x=result.x1,
            y=result.y1,
            dx=result.dx,
            dy=result.dy,
            class_name=result.item.status.value,
            title=result.item.signature,
        )


def render_progress(
    all_functions: list[Function],
    y1: Decimal,
    y2: Decimal,
    x1: Decimal,
    x2: Decimal,
    mode: SumMode,
) -> Iterable[Shape]:
    x = x1

    def sorter(function):
        return function.status.value

    for status_value, iter_group in groupby(
        sorted(all_functions, key=sorter), sorter
    ):
        group = list(iter_group)
        match mode:
            case SumMode.COUNT:
                ratio = Decimal(len(group)) / Decimal(len(all_functions))
            case SumMode.BYTES:
                ratio = Decimal(
                    sum(function.size for function in group)
                ) / Decimal(sum(function.size for function in all_functions))
            case _:
                assert False
        yield Rectangle(
            x=x,
            y=y1,
            dx=x1 + (x2 - x1) * ratio,
            dy=y2 - y1,
            class_name=status_value,
        )
        x += (x2 - x1) * ratio


def render_svg(all_functions: list[Function]) -> Iterable[Shape]:
    y = ZERO
    yield Text(
        ZERO,
        y,
        "Tomb2.exe functions, arranged according to the physical file layout:",
    )
    y = TEXT_SIZE + TEXT_MARGIN

    shapes = list(
        render_progress(
            all_functions,
            y,
            y + GRID_SQUARE_SIZE,
            ZERO,
            (
                GRID_MAX_SQUARES * (GRID_SQUARE_SIZE + GRID_SQUARE_MARGIN)
                - GRID_SQUARE_MARGIN
            ),
            mode=SumMode.COUNT,
        ),
    )
    yield from shapes
    y = max(shape.box.y2 for shape in shapes)
    y += GRID_SQUARE_MARGIN

    shapes = list(render_grid(all_functions, y))
    yield from shapes

    y = max(shape.box.y2 for shape in shapes)
    y += SECTION_MARGIN
    yield Text(
        ZERO, y, "Tomb2.exe functions, arranged according to the function sizes:"
    )
    y += TEXT_SIZE + TEXT_MARGIN
    dx = max(shape.box.x2 for shape in shapes)

    shapes = list(
        render_progress(
            all_functions,
            y,
            y + GRID_SQUARE_SIZE,
            ZERO,
            (
                GRID_MAX_SQUARES * (GRID_SQUARE_SIZE + GRID_SQUARE_MARGIN)
                - GRID_SQUARE_MARGIN
            ),
            mode=SumMode.BYTES,
        ),
    )
    yield from shapes
    y = max(shape.box.y2 for shape in shapes)
    y += GRID_SQUARE_MARGIN

    shapes = list(
        render_tree_grid(all_functions, Box(x1=ZERO, y1=y, x2=dx, y2=y + y))
    )
    yield from shapes

    y = max(shape.box.y2 for shape in shapes)
    y += SECTION_MARGIN

    ready_functions = [func for func in all_functions if func.is_decompiled]
    named_functions = [
        func
        for func in all_functions
        if func.is_named and func not in ready_functions
    ]
    todo_functions = [
        func
        for func in all_functions
        if func not in ready_functions and func not in named_functions
    ]

    def sum_size(functions: Iterable[Function]) -> int:
        return sum(func.size for func in functions)

    yield Text(x=ZERO, y=y, text="Lenged:")
    y += TEXT_SIZE + TEXT_MARGIN
    for status, text, functions in [
        (
            FunctionStatus.DECOMPILED,
            "Function fully decompiled",
            ready_functions,
        ),
        (
            FunctionStatus.NAMED,
            "Function not yet decompiled, but with a known name",
            named_functions,
        ),
        (
            FunctionStatus.TODO,
            "Function not yet decompiled, with an unknown name",
            todo_functions,
        ),
    ]:
        yield LegendText(
            x=ZERO,
            y=y,
            class_name=status.value,
            text=f"{text}",
        )
        y += TEXT_SIZE + LEGEND_ROW_PADDING


def main() -> None:
    functions = list(collect_functions())

    with PROGRESS_SVG_FILE.open("w") as handle:
        shapes = list(render_svg(functions))
        bbox = get_common_bbox(shapes)

        svg = (
            f"""
        <svg version="1.1"
            viewBox="{format_decimal(-DOCUMENT_MARGIN)} {format_decimal(-DOCUMENT_MARGIN)} {format_decimal(bbox.dx + DOCUMENT_MARGIN * 2)} {format_decimal(bbox.dy + DOCUMENT_MARGIN * 2)}"
            xmlns="http://www.w3.org/2000/svg">
            <style>
                .todo {{ fill: rgba(255, 255, 255, 0.25); stroke: rgba(100, 100, 100, 0.5); stroke-width: 0.5; }}
                .named {{ fill: rgba(255, 255, 0, 0.25); stroke: rgba(250, 150, 0, 0.85); }}
                .decompiled {{ fill: rgba(0, 255, 0, 0.5); stroke: rgba(0, 150, 0, 0.85); }}
                text {{ alignment-baseline: central; font-family: sans-serif; font-size: {TEXT_SIZE}px; }}
            </style>
        """
            + "\n".join(shape.render() for shape in shapes)
            + "</svg>"
        )

        print(svg, file=handle)


if __name__ == "__main__":
    main()
